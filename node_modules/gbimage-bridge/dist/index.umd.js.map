{"version":3,"file":"index.umd.js","sources":["../src/index.tsx"],"sourcesContent":["import BackgroundImage, {\n  IBackgroundImageProps,\n  IFixedObject,\n  IFluidObject,\n} from 'gatsby-background-image';\nimport { IGatsbyImageData } from 'gatsby-plugin-image/dist/src/components/gatsby-image.browser';\nimport React, { FunctionComponent } from 'react';\n\ntype IBaseBgImageProps = Omit<IBackgroundImageProps, 'fluid' | 'fixed'>;\nexport interface IBgImageProps extends IBaseBgImageProps {\n  image?: IGatsbyImageData;\n}\n\nexport interface IGatsbyImageDataExtended extends IGatsbyImageData {\n  media?: string;\n}\n\n/**\n * Tests a given value on being a string.\n *\n * @param value *   Value to test\n * @return {boolean}\n */\nexport const isString = (value: string | IGatsbyImageDataExtended): boolean =>\n  Object.prototype.toString.call(value) === '[object String]';\n\n/**\n * Returns the type of the imageData object.\n *\n * @param {IGatsbyImageData} imageData\n */\nexport const getBgImageType = (imageData: IGatsbyImageDataExtended): string =>\n  imageData.layout === 'fixed' ? 'fixed' : 'fluid';\n\n/**\n * Gives back the first image it finds.\n *\n * @param imageData\n */\nexport const getSingleImage = (\n  imageData: (string | IGatsbyImageDataExtended)[]\n): IGatsbyImageDataExtended | null => {\n  let i: number;\n  for (i = 0; i < imageData.length; i++) {\n    if (isString(imageData[i])) continue;\n    // @ts-ignore\n    return imageData[i];\n  }\n  return null;\n};\n\n/**\n * Converts the aspect ratio to width & height.\n *\n * @param {IGatsbyImageData} imageData\n */\nexport const getAspectRatio = (imageData: IGatsbyImageDataExtended): number =>\n  imageData.width / imageData.height;\n\ninterface IPlaceholderData {\n  base64?: string;\n  tracedSVG?: string;\n}\n\n/**\n * Extracts the placeholder image (if any).\n *\n * @param {IGatsbyImageData} imageData\n */\nexport const getPlaceholder = (\n  imageData: IGatsbyImageDataExtended\n): IPlaceholderData => {\n  if (imageData.placeholder) {\n    return imageData.placeholder?.fallback?.includes(`base64`)\n      ? { base64: imageData.placeholder?.fallback }\n      : { tracedSVG: imageData.placeholder?.fallback };\n  }\n  return {};\n};\n\n/**\n * Extracts the extra src{Type} from sources srcSets.\n *\n * @param {object} sourceImage\n */\nexport const getSrc = (sourceImage: {\n  srcSet: string;\n  type: string;\n  sizes: string;\n}): string => {\n  if (sourceImage.srcSet) {\n    const srcSetRegex = /(?:([^\"'\\s,]+)\\s*(?:\\s+\\d+[wx])(?:,\\s*)?)/gm;\n    const allSources = [...sourceImage.srcSet.matchAll(srcSetRegex)];\n    const size = sourceImage.sizes.replace('px', '');\n    const initialSource = allSources.filter(src => {\n      return (\n        src?.[0].includes('100w') ||\n        src?.[0].includes('1x') ||\n        src?.[0].includes(`${size}w`)\n      );\n    });\n    return initialSource?.[0]?.[1] || '';\n  }\n  return '';\n};\n\n/**\n * Loops through all sources & creates srcSet{Type} entries for `gbi`.\n *\n * @param imageData\n */\nexport const getAllExtraSrcSets = (imageData: IGatsbyImageDataExtended) => {\n  if (imageData.images?.sources && Array.isArray(imageData.images?.sources)) {\n    return imageData.images?.sources.reduce((srcSets, sourceImage) => {\n      const typeFromMime = sourceImage?.type?.split('/')[1] || '';\n      const sourceType =\n        typeFromMime?.charAt(0).toUpperCase() + typeFromMime.slice(1);\n      const possibleExtraSrcSet = `srcSet${sourceType}`;\n      const possibleExtraSrc = `src${sourceType}`;\n      if (sourceType) {\n        if (!(possibleExtraSrcSet in srcSets) && sourceImage?.srcSet) {\n          // @ts-ignore\n          srcSets[possibleExtraSrcSet] = sourceImage.srcSet;\n        }\n        if (!(possibleExtraSrc in srcSets) && sourceImage?.srcSet) {\n          // @ts-ignore\n          srcSets[possibleExtraSrc] = getSrc(sourceImage);\n        }\n      }\n      return srcSets;\n    }, {});\n  }\n  return {};\n};\n\n/**\n *\n *\n * @param imageData\n */\nexport const convertSingleBgImage = (\n  imageData: IGatsbyImageDataExtended\n): Partial<IBackgroundImageProps | null> => {\n  if (imageData && imageData.layout) {\n    const returnBgObject: Partial<IBackgroundImageProps> = {};\n    const bgType = getBgImageType(imageData);\n    const aspectRatio = getAspectRatio(imageData);\n    const placeholder = getPlaceholder(imageData);\n    const extraSrcSets = getAllExtraSrcSets(imageData);\n    // @ts-ignore\n    returnBgObject[bgType] = {\n      ...imageData.images.fallback,\n      ...extraSrcSets,\n      ...placeholder,\n      ...(bgType === 'fluid' ? { aspectRatio } : {}),\n      ...(bgType === 'fixed'\n        ? { width: imageData.width, height: imageData.height }\n        : {}),\n    };\n    return returnBgObject;\n  }\n  return null;\n};\n\n/**\n * Converts an array of images.\n *\n * @param imageData\n */\nconst convertArrayOfImages = (\n  imageData: (string | IGatsbyImageDataExtended)[]\n): [string, Partial<IFixedObject[] | IFluidObject[] | string | null>] | [] => {\n  // TODO: change to not extract from string!\n  const singleImage = getSingleImage(imageData);\n  if (singleImage) {\n    const bgType = getBgImageType(singleImage);\n    const convertedImageArray = imageData.map(\n      (image: IGatsbyImageDataExtended | string) => {\n        if (isString(image)) {\n          return image;\n        }\n        // @ts-ignore\n        const convertedImage = convertSingleBgImage(image);\n        return {\n          // @ts-ignore\n          ...(convertedImage && convertedImage[bgType]),\n          // @ts-ignore\n          ...(image?.media ? { media: image.media } : {}),\n        };\n      }\n    );\n    // @ts-ignore\n    return [bgType, convertedImageArray];\n  }\n  return [];\n};\n\n/**\n * Tries to Backport the new `gatsbyImageData` type to the classic `fluid` / `fixed` form.\n *\n * @param {object}    imageData    The image data to convert.\n * @returns {Partial<IBackgroundImageProps>|{}}\n */\nexport function convertToBgImage(\n  imageData:\n    | undefined\n    | IGatsbyImageDataExtended\n    | (string | IGatsbyImageDataExtended)[]\n): Partial<IBackgroundImageProps | IBackgroundImageProps[] | null> {\n  if (imageData) {\n    if (Array.isArray(imageData)) {\n      const [bgType, imageArray] = convertArrayOfImages(imageData);\n      if (bgType) {\n        return {\n          [bgType]: imageArray,\n        };\n      }\n      return null;\n    }\n    return convertSingleBgImage(imageData);\n  }\n  return null;\n}\n\n/**\n * This is a temporary stopgap solution until `<BackgroundImage>` natively supports `gatsby-plugin-image`,\n * see [https://github.com/timhagn/gatsby-background-image/issues/141](https://github.com/timhagn/gatsby-background-image/issues/141).\n *\n * @param {React.PropsWithChildren<IBgImageProps>} props\n * @return {JSX.Element}\n * @constructor\n * @author @rburgst <https://github.com/rburgst> (of the original in the Issue)\n */\nexport const BgImage: FunctionComponent<IBgImageProps> = props => {\n  const { image, children, ...args } = props;\n  const bgImage = image && convertToBgImage(image);\n  if (bgImage) {\n    return (\n      <BackgroundImage {...bgImage} {...args}>\n        {children}\n      </BackgroundImage>\n    );\n  }\n  return <div>{children}</div>;\n};\n"],"names":["isString","value","Object","prototype","toString","call","getBgImageType","imageData","layout","getSingleImage","i","length","getAspectRatio","width","height","getPlaceholder","placeholder","fallback","includes","base64","_imageData$placeholde3","tracedSVG","_imageData$placeholde4","getSrc","sourceImage","srcSet","allSources","matchAll","size","sizes","replace","initialSource","filter","src","getAllExtraSrcSets","images","sources","Array","isArray","_imageData$images2","_imageData$images3","reduce","srcSets","typeFromMime","type","split","sourceType","charAt","toUpperCase","slice","possibleExtraSrcSet","possibleExtraSrc","convertSingleBgImage","returnBgObject","bgType","aspectRatio","extraSrcSets","convertToBgImage","singleImage","convertedImageArray","map","image","convertedImage","media","convertArrayOfImages","props","children","args","bgImage","React","BackgroundImage"],"mappings":"8oBAuBaA,EAAW,SAACC,SACmB,oBAA1CC,OAAOC,UAAUC,SAASC,KAAKJ,IAOpBK,EAAiB,SAACC,SACR,UAArBA,EAAUC,OAAqB,QAAU,SAO9BC,EAAiB,SAC5BF,GAEA,IAAIG,EACJ,IAAKA,EAAI,EAAGA,EAAIH,EAAUI,OAAQD,IAChC,IAAIV,EAASO,EAAUG,IAEvB,OAAOH,EAAUG,GAEnB,aAQWE,EAAiB,SAACL,UAC7BA,EAAUM,MAAQN,EAAUO,QAYjBC,EAAiB,SAC5BR,eAEA,OAAIA,EAAUS,qBACLT,EAAUS,yBAAaC,aAAUC,mBACpC,CAAEC,gBAAQZ,EAAUS,oBAAVI,EAAuBH,UACjC,CAAEI,mBAAWd,EAAUS,oBAAVM,EAAuBL,UAEnC,IAQIM,EAAS,SAACC,GAKrB,GAAIA,EAAYC,OAAQ,OAEhBC,YAAiBF,EAAYC,OAAOE,SADtB,gDAEdC,EAAOJ,EAAYK,MAAMC,QAAQ,KAAM,IACvCC,EAAgBL,EAAWM,OAAO,SAAAC,GACtC,aACEA,SAAAA,EAAM,GAAGf,SAAS,iBAClBe,SAAAA,EAAM,GAAGf,SAAS,eAClBe,SAAAA,EAAM,GAAGf,SAAYU,UAGzB,aAAOG,YAAAA,EAAgB,aAAK,KAAM,GAEpC,MAAO,IAQIG,EAAqB,SAAC3B,aACjC,gBAAIA,EAAU4B,WAAQC,SAAWC,MAAMC,iBAAQ/B,EAAU4B,eAAVI,EAAkBH,kBACxD7B,EAAU4B,eAAVK,EAAkBJ,QAAQK,OAAO,SAACC,EAASlB,SAC1CmB,SAAenB,YAAAA,EAAaoB,eAAMC,MAAM,KAAK,KAAM,GACnDC,SACJH,SAAAA,EAAcI,OAAO,GAAGC,eAAgBL,EAAaM,MAAM,GACvDC,WAA+BJ,EAC/BK,QAAyBL,EAW/B,OAVIA,MACII,KAAuBR,UAAYlB,GAAAA,EAAaC,SAEpDiB,EAAQQ,GAAuB1B,EAAYC,UAEvC0B,KAAoBT,UAAYlB,GAAAA,EAAaC,SAEjDiB,EAAQS,GAAoB5B,EAAOC,KAGhCkB,GACN,IAEE,IAQIU,EAAuB,SAClC7C,GAEA,GAAIA,GAAaA,EAAUC,OAAQ,CACjC,IAAM6C,EAAiD,GACjDC,EAAShD,EAAeC,GACxBgD,EAAc3C,EAAeL,GAC7BS,EAAcD,EAAeR,GAC7BiD,EAAetB,EAAmB3B,GAWxC,OATA8C,EAAeC,QACV/C,EAAU4B,OAAOlB,SACjBuC,EACAxC,EACY,UAAXsC,EAAqB,CAAEC,YAAAA,GAAgB,GAC5B,UAAXD,EACA,CAAEzC,MAAON,EAAUM,MAAOC,OAAQP,EAAUO,QAC5C,IAECuC,EAET,sBA0CcI,EACdlD,GAKA,GAAIA,EAAW,CACb,GAAI8B,MAAMC,QAAQ/B,GAAY,SAzCL,SAC3BA,GAGA,IAAMmD,EAAcjD,EAAeF,GACnC,GAAImD,EAAa,CACf,IAAMJ,EAAShD,EAAeoD,GACxBC,EAAsBpD,EAAUqD,IACpC,SAACC,GACC,GAAI7D,EAAS6D,GACX,OAAOA,EAGT,IAAMC,EAAiBV,EAAqBS,GAC5C,YAEMC,GAAkBA,EAAeR,SAEjCO,GAAAA,EAAOE,MAAQ,CAAEA,MAAOF,EAAME,OAAU,MAKlD,MAAO,CAACT,EAAQK,GAElB,MAAO,GAiB0BK,CAAqBzD,GAA3C+C,OACP,OAAIA,UAECA,gBAKP,OAAOF,EAAqB7C,GAE9B,sBAYuD,SAAA0D,OAC/CJ,EAA6BI,EAA7BJ,MAAOK,EAAsBD,EAAtBC,SAAaC,qIAASF,wBAC/BG,EAAUP,GAASJ,EAAiBI,GAC1C,OAAIO,EAEAC,wBAACC,2BAAoBF,EAAaD,GAC/BD,GAIAG,mCAAMH"}